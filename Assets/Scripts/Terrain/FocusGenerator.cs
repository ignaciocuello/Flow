using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

[ExecuteInEditMode]
public class FocusGenerator : MonoBehaviour {

    [SerializeField]
    private Sprite activeSprite;
    [SerializeField]
    private Sprite inactiveSprite;

    //spawn point relative to this generator
    [SerializeField]
    private Vector2 spawnPoint;
    private Door door;


    //trajectory data of launch
    [SerializeField]
    private TrajectoryModData launchData;

    //if false, does not generate focus
    [SerializeField]
    private bool active;
    public bool Active
    {
        get { return active; }
    }

    //if true, will deactivate on focus death
    [SerializeField]
    private bool deactivateOnFocusDeath;
    //true if focus generated are animated when timeScale = 0
    public bool AnimateFocusWhenTimeFrozen;

    [SerializeField, Tooltip("how much to delay before a focus is generated, once the current focus has died (in frames)")]
    private int focusGenerationDelay;
    //how many frames we have to delay til we can spawn a focus
    private int currentDelay;

    //this will be called whenever a focus created by this generator enters the dead state
    [SerializeField]
    private EntityStateEvent onFocusDiedEventProxy;
    //this will be called whenever a focus created by this generator enters a state
    public EntityStateEvent OnFocusEnteredStateEventProxy;

    //the focus generated by this generator, null if none active
    private Focus focus;

    private SpriteRenderer spriteRenderer;

    private void OnValidate()
    {
        //GetComponent<BoxCollider2D>().size = size;

        //SpriteRenderer sr = GetComponent<SpriteRenderer>();
        //sr.size = new Vector2(sr.size.x, size.y);
    }

    private void Awake()
    {
        door = GetComponent<Door>();
        spriteRenderer = GetComponent<SpriteRenderer>();
        spriteRenderer.sprite = active ? activeSprite : inactiveSprite;
    }

    private void Start()
    {
        if (active)
        {
            GenerateFocus();
        }
    }

    private void FixedUpdate()
    {
        CheckIfAbleToGenerateFocus();
    }

    private void CheckIfAbleToGenerateFocus()
    {
        if (active && focus == null)
        {
            if (currentDelay == 0)
            {
                GenerateFocus();
            }
            else
            {
                currentDelay--;
            }
        }
    }

    public void GenerateFocus()
    {
        //this is here to prevent a null reference exception in the editor
        if (EntityFactory.Instance != null)
        {
            focus = EntityFactory.Instance.Create<Focus>();
            focus.AnimateWhenTimeFrozen = AnimateFocusWhenTimeFrozen;
            focus.gameObject.SetActive(true);

            focus.transform.position = (Vector2)transform.TransformPoint(spawnPoint * door.Size);

            focus.Impact(launchData);

            focus.OnEnterStateEvent.AddListener(OnFocusStateChange);
        }
    }

    void OnFocusStateChange(EntityState state)
    {
        if (state is DeadFocusState)
        {
            if (deactivateOnFocusDeath)
            {
                Deactivate();
            }    

            onFocusDiedEventProxy.Invoke(state);

            focus.OnEnterStateEvent.RemoveListener(OnFocusStateChange);
            focus = null;

            currentDelay = focusGenerationDelay;
        }

        OnFocusEnteredStateEventProxy.Invoke(state);
    }

    //need this function, to be able to call from editor
    public void Activate()
    {
        active = true;
        spriteRenderer.sprite = activeSprite;

        if (focus == null) 
        {
            GenerateFocus();
        }
    }

    public void Deactivate()
    {
        active = false;
        spriteRenderer.sprite = inactiveSprite;
    }
}
